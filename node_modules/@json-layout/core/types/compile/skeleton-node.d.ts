/**
 * @param {any} rawSchema
 * @param {string} sourceSchemaId
 * @param {import('./index.js').CompileOptions} options
 * @param {(schemaId: string, ref: string) => [any, string, string]} getJSONRef
 * @param {Record<string, import('./types.js').SkeletonTree>} skeletonTrees
 * @param {Record<string, import('./types.js').SkeletonNode>} skeletonNodes
 * @param {string[]} validates
 * @param {Record<string, string[]>} validationErrors
 * @param {Record<string, import('@json-layout/vocabulary').NormalizedLayout>} normalizedLayouts
 * @param {import('@json-layout/vocabulary').Expression[]} expressions
 * @param {string | number} key
 * @param {string} pointer
 * @param {boolean} required
 * @param {string} [condition]
 * @param {boolean} [dependent]
 * @param {string} [knownType]
 * @returns {import('./types.js').SkeletonNode}
 */
export function makeSkeletonNode(rawSchema: any, sourceSchemaId: string, options: import('./index.js').CompileOptions, getJSONRef: (schemaId: string, ref: string) => [any, string, string], skeletonTrees: Record<string, import('./types.js').SkeletonTree>, skeletonNodes: Record<string, import('./types.js').SkeletonNode>, validates: string[], validationErrors: Record<string, string[]>, normalizedLayouts: Record<string, import('@json-layout/vocabulary').NormalizedLayout>, expressions: import('@json-layout/vocabulary').Expression[], key: string | number, pointer: string, required: boolean, condition?: string | undefined, dependent?: boolean | undefined, knownType?: string | undefined): import('./types.js').SkeletonNode;
//# sourceMappingURL=skeleton-node.d.ts.map